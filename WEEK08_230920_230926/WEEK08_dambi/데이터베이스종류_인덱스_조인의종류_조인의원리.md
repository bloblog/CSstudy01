# 4.4 ~ 4.7

날짜: 2023/09/25
태그: study
세부항목: CS스터디, SSAFY
velog/blog/git: git

## 4.4 데이터베이스의 종류

[https://youtu.be/z9chRlD1tec?si=wCv7J6voM2C79YOC](https://youtu.be/z9chRlD1tec?si=wCv7J6voM2C79YOC)

[https://youtu.be/Q_9cFgzZr8Q?si=n3-xuT-_l-fN_FgT](https://youtu.be/Q_9cFgzZr8Q?si=n3-xuT-_l-fN_FgT)

### 4.4.1 관계형 데이터베이스

- 관계형 데이터베이스 RDBM
    - 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스
    - SQL언어 써서 조작

- MySQL
    - 운영체제와 호환
    - 현재 가장 많이 사용되는 데이터베이스
    - C, C++
    - 대용량 데이터베이스를 위해 설계
    - 롤백, 커밋, 이중 암호 지원 보안 등의 기능을 제공
    
    - 스토리지 엔진 아키텍처
        - 모듈식 아키텍처
        - 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리
        - 커넥터 API 및 서비스 계층을 통해 DB에 쉡게 상호 작용 가능
    
- PostgreSQL
    - MySQL다음으로 쓰임
    - 디스크 조각 차이 회수 → VACUUM이 특징

### NoSQL 데이터베이스

- NoSQL
    - Not only SQL
    - SQL을 사용하지 않는 데이터베이스
    - MangoDB, redis

- MangoDB
    - JSON을 통해 데이터 접근 → Binary JSON형태로 저장
    - 와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 DB → ?
    - 확장성이 뛰어남, 빅데이터를 저장할 때 성능이 좋음
    - 고가용성과 샤딩, 레플리카셋을 지원
    - 스키마 정하지 않고 데이터 삽입 가능 → 다양한 데이터베이스를 기반으로 분석 or 로깅 등을 구현할 때 강점
    - 유니크 ObjectID 생성

- redis
    - 인메모리 DB
    - 키-값 데이터 모델 기반 DB
    - 기본적인 데이터 타입은 문자열 (512mb까지 저장가능)
    - 셋set, 해시hash 등 지원
    - pub/sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된 셋 자료 구조를 이용한 실시간 순위표 서비스에 사용
    

---

## 4.5 인덱스

### 4.5.1 인덱스의 필요성

- 인덱스
    - 데이터를 빠르게 찾을 수 있는 하나의 장치

### 4.5.2 B-트리

- B - 트리
    - 인덱스의 자료구조 형태(일반적)
    - 루트, 리프 노드 + 브랜치 노드
    - 노드를 나눠 짧은 시간 내에 진입 시도

- 인덱스가 효율적인 이유와 대수확장성
    - 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문
        
        ⇒ 대수확장성: 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장
        
    

### 4.5.3 인덱스 만드는 방법

- MySQL
    - 클러스터형 인덱스 & 세컨더리 인덱스
        - 클러스터형 인덱스
            - 테이블 당 하나 설정
        - 세컨더리 인덱스
            - 보조인덱스
            - 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성

- MongoDB
    - 도큐먼트를 만들면 자동으로 ObjectID 형성
    - 해당 키가 기본으로 설정

### 4.5.4 인덱스 최적화 기법

- 인덱스는 비용이다.
    - 인덱스 → 두 번 탐색하도록 강요
    - 인덱스 리스트, 그다음 컬렉션 순으로 탐색함 → 읽기 비용이 들어감
    - 컬렉션 수정 시 → 인덱스도 수정되어야 함
    
    ⇒ 모든 필드에 인덱스 무작정 설정 x
    

- 테스팅
    - 테스팅을 통한 최적화
    - explain함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간 최소화
    
    ```jsx
    EXPLAIN
    SELECT * FROM t1
    JOIN t2 ON t1.c1 = t2,c1
    ```
    

- 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순
    1. 같음 비교가 있다면 제일 먼저 인덱스로 설정
    2. 정렬에 쓰이는 필드 → 다음 인덱스임
    3. 다중 값 출력 필드 (범위 등) → 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스 설정
    4. 유니크한 값의 정도를 카디널리티라고 함 → 카디널리티가 높은 순서를 기반으로 인덱스 생성
    

---

## 4.6 조인의 종류

- 조인 join
    - 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것
    - 여러 테이블을 조인하는 작업이 많을 경우 → 관계형 DB를 쓰는게 좋음

### 4.6.1 내부 조인 inner join

```jsx
SELECT * FROM TableA A
INNER JOIN TableB B ON
A.key = B.key
```

### 왼쪽 조인 left outer join

```jsx
SELECT * FROM TableA A
LEFT JOIN TableB B ON
A.key = B.key
```

### 오른쪽 조인 right outer join

```jsx
SELECT * FROM TableA A
RIGHT JOIN TableB B ON
A.key = B.key
```

### 합집합 full outer join

```jsx
SELECT * FROM TableA A
FULL OUTER JOIN TableB B ON
A.key = B.key
```

---

## 4.7 조인의 원리

### 4.71 중첩 루프 조인

- 중첩 루프 조인
    - 중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법
    - 랜덤 접근에 대한 비용 많이 증가 → 대용량 테이블에서는 사용하지 x
    - 블록 중첩 루프 조인 (테이블을 작은 블록으로 나눠서 조인)

### 4.7.2 정렬 병합 조인

- 정렬 병합 조인
    - 각각의 테이블을 조인할 필드 기준으로 정렬 → 정렬 이후 조인 작업 수향
    - 조인 조건으로 범위 비교 연산자가 있을 때 씀

### 4.7.3 해시 조인

- 해시 조인
    - 해시 테이블을 기반으로 조인하는 방법
    - 하나의 테이블이 메모리에 온전히 들어간다면 → 중첩루프 조인보다 효율적
    - 동등 조인에서만 사용 가능
    - 빌드 단계
        - 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
    - 프로브 단계
        - 레코드를 읽기 시작함
    - 두 개의 테이블을 읽는 중첩 루프 조인보다 보통 성능이 더 좋음